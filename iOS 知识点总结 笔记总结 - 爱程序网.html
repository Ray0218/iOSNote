<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0035)http://www.aichengxu.com/view/47974 -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <style id="znBdcsStyle" type="text/css">#bdcs-rec{display:none;}</style>
        <title>iOS 知识点总结    笔记总结 - 爱程序网</title>
        <meta name="Keywords" content="iOS 知识点总结    笔记总结">
        <meta name="Description" content="在这里给大家推荐一个非常棒的笔记软件。pc端和app端都有======印象笔记1、全局变量，变量名前加下划线。和系统一致。2、nil指针为空@“”字符串为空">        
        <link type="text/css" rel="stylesheet" href="./iOS 知识点总结 笔记总结 - 爱程序网_files/layout.css">
<script type="text/javascript" async="" src="./iOS 知识点总结 笔记总结 - 爱程序网_files/js"></script><script src="./iOS 知识点总结 笔记总结 - 爱程序网_files/hm.js"></script><script type="text/javascript" src="./iOS 知识点总结 笔记总结 - 爱程序网_files/jquery-1.3.2.min.js"></script><style type="text/css"></style>
<script type="text/javascript" src="http://www.aichengxu.com/Public/Js/ad.js?v=20150508"></script>

    </head>
    <body>
        <div id="wrap">
            <div id="header">
                <div class="logo">
                   <a href="http://www.aichengxu.com/"><img width="311" height="48" alt="爱程序网" src="./iOS 知识点总结 笔记总结 - 爱程序网_files/logo.png"></a>
                </div>
                <div class="search">
                    <form target="_blank" action="http://zhannei.baidu.com/cse/search">           
                        <div class="search-ipt">
                            <input id="bdcsMain" type="text" value="" name="q">
                        </div>
                        <div class="search-btn">
                            <input type="submit" value="搜索" class="sub-btn">
                        </div>
                    <div><input type="hidden" name="s" value="13701196898887196136"><input type="hidden" name="entry" value="1"></div></form>
                </div>
            </div>
            <div id="nav">
                <ul>
                <li><a href="http://www.aichengxu.com/">首页</a></li>
                <li><a href="http://www.aichengxu.com/item/1">PHP学习</a></li><li><a href="http://www.aichengxu.com/item/15">Python教程</a></li><li><a href="http://www.aichengxu.com/item/10">MySQL学习</a></li><li><a href="http://www.aichengxu.com/item/7">JS特效</a></li><li><a href="http://www.aichengxu.com/item/6">CSS特效</a></li><li><a href="http://www.aichengxu.com/item/4">C++教程</a></li><li><a href="http://www.aichengxu.com/item/3">.NET开发</a></li><li><a href="http://www.aichengxu.com/item/2">Java教程</a></li> 
                   
                   <li>   <a class="nav-more">更多</a>   <b class="verify-b"></b>   
                   <div class="drop-sub-nav" style="display:none;">   
                   <a href="http://www.aichengxu.com/item/14">ThinkPHP</a><a href="http://www.aichengxu.com/item/12">电脑优化</a><a href="http://www.aichengxu.com/item/11">C语言学习</a><a href="http://www.aichengxu.com/item/8">网站SEO优化</a><a href="http://www.aichengxu.com/item/5">HTML语法</a><a href="http://www.aichengxu.com/item/21">整理收藏</a>                   </div>
                   </li>                
                 </ul>
            </div>           
	<div class="top-nav-ad">
		<table class="cate-table">
	<tbody><tr>    <td><a title="IT技术文章分类整理收藏夹" target="_blank" href="http://www.lai18.com/">《IT技术文章分类整理》收藏夹(10000+篇)</a></td>
    
        <td><a title="PHP模板引擎Smarty收藏夹" target="_blank" href="http://www.lai18.com/cate/105.html">《PHP模板引擎Smarty》收藏夹(7篇)</a></td>
    
        <td><a title="详解PHP面向对象收藏夹" target="_blank" href="http://www.lai18.com/cate/119.html">《详解PHP面向对象》收藏夹(31篇)</a></td>
    
        <td><a title="Linux常用命令收藏夹" target="_blank" href="http://www.lai18.com/cate/48.html">《Linux常用命令》收藏夹(38篇)</a></td>
    
    </tr><tr>    <td><a title="汤姆大叔MVC系列收藏夹" target="_blank" href="http://www.lai18.com/cate/125.html">《汤姆大叔MVC系列》收藏夹(16篇)</a></td>
    
        <td><a title="解读ASP.NET5&amp;MVC6收藏夹" target="_blank" href="http://www.lai18.com/cate/124.html">《解读ASP.NET5&amp;MVC6》收藏夹(15篇)</a></td>
    
        <td><a title="基于JQuery和CSS的特效整理收藏夹" target="_blank" href="http://www.lai18.com/cate/163.html">《基于JQuery和CSS的特效整理》收藏夹(71篇)</a></td>
    
        <td><a title="编程实用算法实现整理收藏夹" target="_blank" href="http://www.lai18.com/cate/52.html">《编程实用算法实现整理》收藏夹(89篇)</a></td>
    
    </tr><tr>    <td><a title="Memcache技术学习收藏夹" target="_blank" href="http://www.lai18.com/cate/179.html">《Memcache技术学习》收藏夹(132篇)</a></td>
    
        <td><a title="PHP发送邮件PHPMailer收藏夹" target="_blank" href="http://www.lai18.com/cate/111.html">《PHP发送邮件PHPMailer》收藏夹(31篇)</a></td>
    
        <td><a title="PHP数据库PDO系列收藏夹" target="_blank" href="http://www.lai18.com/cate/172.html">《PHP数据库PDO系列》收藏夹(32篇)</a></td>
    
        <td><a title="MongoDB技术知识收藏夹" target="_blank" href="http://www.lai18.com/cate/99.html">《MongoDB技术知识》收藏夹(50篇)</a></td>
    
    </tr><tr>    <td><a title="戴文的Linux内核专题收藏夹" target="_blank" href="http://www.lai18.com/cate/189.html">《戴文的Linux内核专题》收藏夹(28篇)</a></td>
    
        <td><a title="Yaf零基础学习总结收藏夹" target="_blank" href="http://www.lai18.com/cate/60.html">《Yaf零基础学习总结》收藏夹(18篇)</a></td>
    
        <td><a title="PHP基础知识总结收藏夹" target="_blank" href="http://www.lai18.com/cate/88.html">《PHP基础知识总结》收藏夹(32篇)</a></td>
    
        <td><a title="Artech的WCF剖析系列收藏夹" target="_blank" href="http://www.lai18.com/cate/136.html">《Artech的WCF剖析系列》收藏夹(100篇)</a></td>
    
    </tr></tbody></table><!--
<script type="text/javascript">
    /*960*90 创建于 2015-04-14*/
    var cpro_id = "u2044562";
</script>
<script src="http://cpro.baidustatic.com/cpro/ui/c.js" type="text/javascript"></script>
-->
</div> 

             
<div id="user-loc">
    当前位置：<a href="http://www.aichengxu.com/">首页</a>&nbsp;»&nbsp;<a href="http://www.aichengxu.com/item/12">电脑优化</a>
</div>

<div id="post">
    <div class="post-left">   
        <div class="post-detail">
            <h1>iOS 知识点总结    笔记总结</h1>
            <div class="p-info">
                <span class="p-time">2015-03-23 14:10:08</span><span class="p-author">本站整理</span><span class="p-view">浏览(257)</span>
            </div>
        <div class="ad-float"><script type="text/javascript">ad.bdDesc_120600();</script></div>
            <div class="p-text">
<div id="ad-left"><script type="text/javascript">ad.bdDesc_300250();</script></div>
             <p>iOS 知识点总结    笔记总结，有需要的朋友可以参考下。</p><br>

<p><span> 在这里给大家推荐一个 非常棒的 笔记软件 。pc端和app端都有 ======印象笔记<br>
</span></p>
<p><span>1 、全局变量，变量名前加下划线。和系统一致。</span></p>
<span>2 、 nil指针为空  @“”字符串为空 （内容为空）</span><br>
<span>   == 判断内存地址  基本变量</span><br>
<span>  对于一些基本类型 可以使用==来判断，但对于指针类型，使用==则判断的是指针保存的内容地址是否相等，而不是判断内存地址下的内容是否相等（应该通过方法来判断）</span><br>
<span><br>
</span><br>
<span>多个指针可以这向同一个对象</span><br>
<span><br>
</span><br>
<span>3 、判断两个字符串是否相等用 isEqualToString:@“”</span><br>
<span><br>
</span><br>
<span>4、警告框</span><br>
<span>   不需要设置fram</span><br>
<span>   不需要addSubview</span><br>
<span>  如果需要添加多个按钮，在最后一个参数中添加，用逗号隔开，以nil结尾</span><br>
<br>
<span>5 、RGBA 0.0～1.0 灰度（亮度值）   0 0 0 黑色   1 1 1白色</span><br>
<span>6 、control以及其子类都可以绑定方法</span><br>
<span>7、默认在图片上添加按钮，按钮是不能被点击的，是因为默认图片视图不可交互</span><br>
<span>imageView.userInteractionEnable = YES；设置可交互</span><br>
<span><br>
</span><br>
<span>父视图可交互 子视图是否可交互看子视图自己</span><br>
<span>父视图不可交互 子视图也不可交互</span><br>
<span><br>
</span><br>
<span>默认不可交互的 UILabel UIImageView</span><br>
<br>
<span>点击登陆视图上的注册按钮，先把登陆视图移出再添加注册视图</span><br>
<span>点击注册视图上的的返回按钮，先把注册视图移出再添加登陆视图</span><br>
<br>
<span>========================================</span><br>
<span>标题黑色23号字体</span><br>
<span>注释绿色20号字体</span><br>
<span>内容黑色20号字体</span><br>
<span>==========================</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>1 动画</span><br>
<span>// 1 开始动画  beginAnimations</span><br>
<span>[UIView beginAnimations:nil context:nil];</span><br>
<span>//3 设置动画时间  setAnimationDuration</span><br>
<span>[UIView setAnimationDuration:3];</span><br>
<span>[UIView</span><br>
<span>//设置翻转样式</span><br>
<span>setAnimationTransition:UIViewAnimationTransitionCurlUp forView:self.window cache:YES];</span><br>
<span>//设置重复自动反向运动</span><br>
<span>[UIView setAnimationRepeatAutoreverses:YES];</span><br>
<span>//4 终点坐标</span><br>
<span>_image.frame = CGRectMake(320-80, 480-80, 80, 80);</span><br>
<span>//2 提交动画  commitAnimations</span><br>
<span>[UIView commitAnimations];</span><br>
<span><br>
</span><br>
<span>2 成为第一响应 键盘自动弹出</span><br>
<span>[_textFiledYongHuMing becomeFirstResponder]; 成为第一响应</span><br>
<span>resignFirstResponder  释放第一响应</span><br>
<span>//键盘自动消失</span><br>
<span>(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</span><br>
<span>{</span><br>
<span>  NSLog(@"touchesBegan");</span><br>
<span>  [self.window endEditing:YES];</span><br>
<span>}</span><br>
<span>3 视图移除和添加</span><br>
<span>[_zhuCeView removeFromSuperview];</span><br>
<span>[self.window addSubview:_loginView];</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span></span><br>
<span>1 视图控制器类</span><br>
<span>UIViewController</span><br>
<span>单一控制视图,不在入口类中添加过多的代码(增加复杂性)</span><br>
<span> 1 导入头文件</span><br>
<span> 2 创建视图控制器对象</span><br>
<span> 3 把对象赋值给self.window.rootViewController = aVi;</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>2 XIB文件</span><br>
<span> 早期nib文件, .xib结尾</span><br>
<span> 1 .File’s  owner 文件所有者,就是指我们的视图控制器aViewController</span><br>
<span> 2. First Responder 第一响应者</span><br>
<span> 3.View 是视图控制器默认的view</span><br>
<span><br>
</span><br>
<span>self.view就是xib里的那个view</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>3 关联</span><br>
<span>1. xib上的控件与对象(指针关联)</span><br>
<span>  1.1 关联按钮,绑定方法</span><br>
<span>     点击Assistant editor按钮</span><br>
<span>  1.2 右键xib中的控件,直接拖拽到.h文件的属性区域,松开,在弹出的的对话框中写入变量名,connect</span><br>
<span>  1.3 注意,如果想要改变关联之后的变量名,必须删除原有的,连线也要切断,重新拖拽.</span><br>
<span><br>
</span><br>
<span>{</span><br>
<span>  IBOutlet UITextField *_nameTF;</span><br>
<span> //IBOutlet 关键字,就是用来关联指针(.h)和控件(.xib)的</span><br>
<span>//Outlet 出口</span><br>
<span>//IB 前缀Interface Builder(接口建设者)</span><br>
<span>//IB 工具.早期的IB是与XCode分离的不利于开发,现在��到一起</span><br>
<span>}</span><br>
<span><br>
</span><br>
<span>按钮设置图片1 setimage 对应Custom类型  2 backgroudimage 对应system类型     二者区别</span><br>
<span><br>
</span><br>
<span>关联属性IBOutlet</span><br>
<span>关联方法IBAction</span><br>
<span><br>
</span><br>
<span>.h中  @property int age; 在.m里可以直接用_age;</span><br>
<span>如果在.m中创建和_age一样的局部变量,局部变量会覆盖全局变量</span><br>
<span>在.m中self.age == _age</span><br>
<span><br>
</span><br>
<span>关联属性可以将空间拖拽到大括号外(声明区域).如果在大括号外,会自动完成属性的描述,以后使用就可self.age或_age而直接拖拽到大括号中,默认只能使用_age(指针名);</span><br>
<span><br>
</span><br>
<span>4 知识点：在视图控制器中获取window对象。</span><br>
<span>在一个类中获取另一个类的window对象来承载view,需要在这个类中通过另一个的对象打点调用window</span><br>
<span>(导入头文件)</span><br>
<span> 1 找window    ZYAppDelegate *app = [UIApplication sharedApplication].delegate;  获取入口类  .delegate系统做这件事,代理</span><br>
<span> UIWindow *window = app.window;</span><br>
<span></span><br>
<span> 2</span><br>
<span> UIWindow *window = [UIApplication sharedApplication].keyWindow</span><br>
<span><br>
</span><br>
<span>为什么要用window ?</span><br>
<span>在window上添加view</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>5 充分理解</span><br>
<span>window.rootViewController = vc</span><br>
<span>    把vc赋给window的rootViewController，则默认会调用vc中的viewDidLoad方法()，像这样的只有把vc给rootViewController，运行程序才能在window上显示vc的view</span><br>
<span><br>
</span><br>
<span>6 把视图控制器的懒加载放置在动画执行下面</span><br>
<span>window.rootViewController = vc</span><br>
<span>这里把vc赋给window的rootViewController，则默认会调用vc中的viewDidLoad方法，像这样的只有把vc给rootViewController，运行程序才能在window上显示vc的view，而单纯的创建对象是不能显示，这种方法叫做懒加载（lazy load）</span><br>
<span><br>
</span><br>
<span>(loadView/nib文件)来加载view到内存 ——&gt;viewDidLoad函数进一步初始化这些view ——&gt;内存不足时，调用viewDidUnload函数释放views —-&gt;当需要使用view时有回到第一步，如此循环。</span><br>
<span></span><br>
<span>7 为了防止在显示vc的view时，造成的界面错乱（如果把下面的代码放置在动画中，则vc的view的创建和显示整个过程都要执行动画），就将下面的代码放置在动画执行之hou</span><br>
<span><br>
</span><br>
<span>1 视图控制器的传值</span><br>
<span>A 1.1获取用户名</span><br>
<span> 1.2创建一个字符串保存</span><br>
<span> 1.3在vieDidLode中进行赋值</span><br>
<span>B 打点调用直接把源属性的值赋值给目的属性的值</span><br>
<span>c 通过初始化方法,先把用户名保存在一个字符串中,然后在初始化方法中,</span><br>
<span><br>
</span><br>
<span>1  创建对象的属性</span><br>
<span>  2  初始化方法</span><br>
<span>    2.1 创建对象时调用自己写的初始化方法进行初始化把文本框中的字符串传递到初始化方法中从而保存在一个设置好的属性中,然后在ViewDidLoad中把保存的值赋值给目标文本框.</span><br>
<span><br>
</span><br>
<span>在使用视图控制器直接传值时,传值的过程很简单,要么通过设置属性值,要么通过初始化方法来设置 . 但是因为有了界面的显示,要十分明确,只有控件显示之后再把传递过来的值赋给控件的属性加以显示.</span><br>
<span><br>
</span><br>
<span>2 常用控件</span><br>
<span> 2.1 UISegmentedControl</span><br>
<span>  2.1.1创建一个数组,里面添加你需要的对象(最后要加入到UISegmentedControl的选项)</span><br>
<span>     2.1.2 设置按钮属性,并且绑定一个带参数的方法,参数传递的就是你所点击的按钮</span><br>
<span>     2.1.3 </span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>3 三目运算符              {  ++  —  += 双目运算符   }</span><br>
<span>condition?value1:value2;</span><br>
<span>当condition为真,则结果为value1,否则结果为value2;</span><br>
<span><br>
</span><br>
<span>_label.test = isOn?@“开”@“关”</span><br>
<span><br>
</span><br>
<span>BOOL 0为假 非零为真</span><br>
<span>bool 只有0 和 1 两个值   0为假 1为真</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span>  20140718</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 !取反 !YES==NO  可用于判断</span><br>
<span><br>
</span><br>
<span>2 创建数组对象也可以直接用类方法搞定</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span>  20140719</span><br>
<span>==================</span><br>
<span>1 让警告框自动消失</span><br>
<span>[alert dismissWithClickedButtonIndex:0 animated:YES];</span><br>
<span>2 为什么button在设置标题时要用一个方法，而不像lable一样直接用一个属性</span><br>
<span>原因是有时我们对   button做一次点击，需要改变button的标题，只有用方法才能做到，而label是标签，只是用来展示内 容的，要想改变一般都是通过其他的控件，绑定方法来实现，不需要在lable上操作.</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span>  20140721</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 获取按钮标题</span><br>
<span>NSString*b = [buttonName titleForState:UIControlStateNormal];</span><br>
<span>//获取按钮标题 通过标题算出小红条宽度</span><br>
<span>NSString *str = btn.titleLabel.text;</span><br>
<span><br>
</span><br>
<span>2 判断字符串中是否包含某个字符</span><br>
<span>//判断字符串中是否存在某个字符串</span><br>
<span>  NSString*aString = @"1223ll45";</span><br>
<span>//range 范围</span><br>
<span>//NSRange 结构体</span><br>
<span>//location 位置 length 长度;</span><br>
<span> NSRange range = [aString rangeOfString:@"l4"];</span><br>
<span>NSLog(@"============%d===========%d",range.location ,range.length);</span><br>
<span> //法 一</span><br>
<span>  if (range.length==2)</span><br>
<span>  {</span><br>
<span>NSLog(@"判断长度是否为2======不是判断是否存在,是通过长度(范围)判断");</span><br>
<span>  }</span><br>
<span> //法 二</span><br>
<span>  if (range.length == NSNotFound)</span><br>
<span>  {</span><br>
<span>NSLog(@"通过location判断");</span><br>
<span>  }</span><br>
<span></span><br>
<span>//封装  判断某个字符串中是否存在另一个字符串的方法</span><br>
<span>- (BOOL)string:(NSString*)bigString isContainString:(NSString*)smallString</span><br>
<span>{</span><br>
<span>// NSString range = []</span><br>
<span>  NSRange range = [bigString rangeOfString:smallString];</span><br>
<span>  if (range.length == NSNotFound)</span><br>
<span>  {</span><br>
<span>    return NO;</span><br>
<span>  }</span><br>
<span>return YES;</span><br>
<span>}</span><br>
<span>3 字符串截取</span><br>
<span>NSString*aString = @"1223ll45";</span><br>
<span>//字符串截取</span><br>
<span>// NSString*str = [aString substringFromIndex:2];</span><br>
<span>//从某一处开始截取</span><br>
<span>NSLog(@"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;%@",[aString substringFromIndex:2]);</span><br>
<span>//截取到某一处</span><br>
<span>NSLog(@"---------%@",[aString substringToIndex:4]);</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>  //截取某一部分  [aString rangeOfString:@"3l”]是NSRange类型 是一个结构体</span><br>
<span>NSLog(@"&gt;&gt;&gt;&gt;&gt;%@",[aString substringWithRange:[aString rangeOfString:@"3l"]]);</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>4 UIImage:NSObject</span><br>
<span> UIImageView :UIView</span><br>
<span><br>
</span><br>
<span>5 arc4random()真随机</span><br>
<span> random() 假随机</span><br>
<span>6 传参 (查)</span><br>
<span>  1 按钮绑定一个带参数的方法sender</span><br>
<span>  2 延时加载 withObject 传递一个对象</span><br>
<span>  3 动画下落中的 context</span><br>
<span>  4 定时器传参 userInfo</span><br>
<span>4.1 eg:[NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(abc) userInfo:@“Lijian”(此处还可以填一个对象) repeats:YES];</span><br>
<span> -(void)abc</span><br>
<span> {</span><br>
<span>NSLog(@"====================%@",aTimer.userInfo);</span><br>
<span> }</span><br>
<span><br>
</span><br>
<span>7 动画不能写在viewDidLoad</span><br>
<span>//必须在执行viewDidLoad执行完毕之后才能执行动画 把动画塞给viewDidLoad不可取</span><br>
<span>//动画是一个过程,而过程是在有view的基础之上进行</span><br>
<span>8 动画结束方法</span><br>
<span>  [UIView setAnimationDelegate:self];</span><br>
<span></span><br>
<span>  [UIView setAnimationDidStopSelector:@selector(animationDidStop:finished:context:)];</span><br>
<span><br>
</span><br>
<span>9 可以通过animationID来判断是哪个视图</span><br>
<span> if ([animationID isEqualToString:@"view1"])</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span>  20140722</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 频繁的 持续性的 用定时器</span><br>
<span>2  雪花下落</span><br>
<span>  2.1 NStimer + 动画结束方法  定时器中频繁创建,在动画结束方法中频繁的移除,会造成大量磁盘碎片.</span><br>
<span>  2.2 数组 重用</span><br>
<span>  一次性创建30个图片,放在数组中,用的时候就可以去图片,从上方下落,当下落到屏幕外面,回收到数组中,以便下次使用</span><br>
<span>3 宏定义</span><br>
<span>//宏定义 变量别名 增加程序可读性 字母大写</span><br>
<span>#define UNSUED 1;//UNSUED指的就是1</span><br>
<span>#define SUED 2;</span><br>
<span>//程序中出现较多的常量,通过宏定义便于管理</span><br>
<span>宏定义和继承没有关系,一般写在.m中</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>4 自定义类</span><br>
<span>当原有类已经满足不了我们的要求时,我们可以通过 自定义类来完成属性和方法的扩展</span><br>
<span>5 跑马灯</span><br>
<span> 5.1viewController + Animation</span><br>
<span><br>
</span><br>
<span>[UIView beginAnimations:nil context:nil];</span><br>
<span>  [UIView setAnimationDuration:3];</span><br>
<span>//设置重复自动反向运动</span><br>
<span>  [UIView setAnimationRepeatAutoreverses:YES];</span><br>
<span>//设置重复次数</span><br>
<span>  [UIView setAnimationRepeatCount:LONG_MAX];</span><br>
<span>  _lable.frame = CGRectMake(320-50, _lable.frame.origin.y, 50, 22);</span><br>
<span>  [UIView commitAnimations];</span><br>
<span><br>
</span><br>
<span> 5.2自定义类+初始化方法</span><br>
<span> 5.3自定义类+绘图方法</span><br>
<span> //绘图方法 整容方法</span><br>
<span> - (void)drawRect:(CGRect)rect</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span>  20140723</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 椭圆运动</span><br>
<span> 1.1地球运动&gt;坐标改变</span><br>
<span> 1.2 轨迹椭圆&gt;椭圆参数方程(x,y)</span><br>
<span> 1.3 不停的运动 &gt; 定时器</span><br>
<span><br>
</span><br>
<span>2</span><br>
<span>isYES是一个BOOL值</span><br>
<span><br>
</span><br>
<span>isYES = !isYES</span><br>
<span>if(isYES)</span><br>
<span>{</span><br>
<span>}else</span><br>
<span>{</span><br>
<span>}</span><br>
<span>每次会自动取反</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>3 线程</span><br>
<span> 3.1  NSThread*thread = [[NSThread alloc] initWithTarget:self selector:@selector(myThread) object:nil];</span><br>
<span>3.2 //加号方法 创建线程</span><br>
<span>  [NSThread detachNewThreadSelector:@selector(myThred) toTarget:self withObject:nil]</span><br>
<span>  //detach  分离</span><br>
<span>4 //剪裁</span><br>
<span>  imageView.clipsToBounds = YES;</span><br>
<span>  imageView.layer.cornerRadius = 40;</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span> 20140724 星期四</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 进程:一个任务的执行 (会消耗CPU)</span><br>
<span>线程:程序独立调度,独立执行的最小单位. 一个程序至少包含一个主线程,可以包含多个分线程.</span><br>
<span>  分线程是为了防止主线程被卡死.</span><br>
<span>  更新UI一定要放在主线程中</span><br>
<span>NSLog(@"%hhd",[NSThread isMainThread]);</span><br>
<span>当分线程绑定的方法结束时就意味着分线程结束.</span><br>
<span>2 导航控制器</span><br>
<span> UINavigationController : UIViewController</span><br>
<span> SDK软件开发工具包 software development kit</span><br>
<span>使用导航器时需要初始化导航器的根视图控制器(initWithRootViewController:vc),然后把导航器的对象赋给window的根视图控制器,默认界面显示,上方是导航条,下方是导航器的根视图View</span><br>
<span><br>
</span><br>
<span>3 隐藏信号区</span><br>
<span>Supporting Files &gt;info.plist(属性列表文件)&gt;添加View controller-based status bar appearance</span><br>
<span>=====================================================================</span><br>
<span>导航器管理页面跳转：</span><br>
<span>1压栈</span><br>
<span> pushViewController</span><br>
<span>2 出栈</span><br>
<span>2.1 popViewController （只出栈当前的）</span><br>
<span>2.2 popToRootViewController（出栈到根视图控制器）</span><br>
<span> 2.3 popToViewController（出栈到指定的视图控制器）</span><br>
<span><br>
</span><br>
<span>导航条只有一个。</span><br>
<span><br>
</span><br>
<span>导航项可以有多个。</span><br>
<span><br>
</span><br>
<span>3</span><br>
<span>1 第一个界面没有标题，跳转到第二个界面，左上角的按钮默认是标题是Back,点击Back，可以返回到一界面。</span><br>
<span>2 第一界面有标题First，则第二界面左上角按钮默认标题为First，且点击可以返回到一界面。</span><br>
<span>3 如果只是改变第二界面左上角按钮的标题，则需要在第一界面的类中设置backButtonItem，但是不会响应绑定的方法。</span><br>
<span>4 在第二个界面上设置左上角的按钮。则返回逻辑，需要自己处理。</span><br>
<span><br>
</span><br>
<span>优先级：4 &gt; 3 &gt; 2 &gt; 1</span><br>
<span><br>
</span><br>
<span>4 self.navigationItem.titleView </span><br>
<span>================================================================</span><br>
<span>// UIBarButtonItem</span><br>
<span>// 1 initWithTitle 标题</span><br>
<span>// 2 initWithBarButtonSystemItem 系统</span><br>
<span>// 3 initWithCustomView  自定义视图</span><br>
<span>// 4 initWithImage 图片</span><br>
<span>// 5 initWithImage:landscapeImagePhone: 图片（包括竖屏和横屏显示不同的图片）</span><br>
<span>UIBarButtonItem *rigthBtnItem= [[UIBarButtonItem alloc]initWithImage:[UIImage imageNamed:@"down.png"] landscapeImagePhone:[UIImage imageNamed:@"up.png"] style:UIBarButtonItemStylePlain target:self action:@selector(rightBtnClick)];</span><br>
<span><br>
</span><br>
<span>self.navigationItem.rightBarButtonItem =rigthBtnItem;</span><br>
<span>=====================================================================</span><br>
<span>// 行为表</span><br>
<span>// UIActionSheet UIAlertView</span><br>
<span>// destructive 谨慎操作的按钮标题</span><br>
<span>UIActionSheet *sheet = [[UIActionSheet alloc]initWithTitle:@"tips" delegate:nil cancelButtonTitle:@"Cancel" destructiveButtonTitle:@"Delete" otherButtonTitles:@"Save", nil];</span><br>
<span>// showInView 在视图上显示</span><br>
<span>[sheet showInView:self.view];</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span> 20140725 星期五</span><br>
<span>==================</span><br>
<span>1 -(void)viewWillAppear:(BOOL)animated 即将显示</span><br>
<span><br>
</span><br>
<span>获取按钮标题</span><br>
<span>获取按钮的标题</span><br>
<span>  UIButton *button = (UIButton *)sender;</span><br>
<span>NSString *number = [button titleForState:UIControlStateNormal];</span><br>
<span></span><br>
<span>-(void)fire 让定时器立即执行</span><br>
<span>1. 让定时器立即执行</span><br>
<span>[timer fire]让定时器直接运行  //不建议使用,fire能让定时器立即开启</span><br>
<span>2.遍历的两种方法               (泛型遍历)        不是同一种对象用ID接收</span><br>
<span>   如果数组中的存放的类型不统一,或者不清楚数组中是什么类型,则可以使用ID类型的变量来接收</span><br>
<span><br>
</span><br>
<span> v=========堆 栈 静态===========v</span><br>
<span>堆 堆（英语：heap)亦被称为：优先队列（英语：priority queue），是[url=x-dictionary:r:]计算机科学[/url]中一类特殊的[url=x-dictionary:r:]数据结构[/url]的统称。堆通常是一个可以被看做一棵树的数组对象。在[url=x-dictionary:r:]队列[/url]中，调度程序反复提取队列中第一个作业并运行，因而实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构</span><br>
<span> 栈 堆栈（[url=x-dictionary:r:]英语[/url]：stack），也可直接称栈。台湾作堆叠，在[url=x-dictionary:r:]计算机科学[/url]中，是一种特殊的串行形式的数据结构，它的特殊之处在于只能允许在链结串行或阵列的一端（称为堆栈顶端指标，[url=x-dictionary:r:]英语[/url]：top）进行加入资料（[url=x-dictionary:r:]英语[/url]：push）和输出资料（[url=x-dictionary:r:]英语[/url]：pop）的运算。另外堆栈也可以用一维[url=x-dictionary:r:]阵列[/url]或[url=x-dictionary:r:]连结串行[/url]的形式来完成。堆栈的另外一个相对的操作方式称为[url=x-dictionary:r:]伫列[/url]。</span><br>
<span>由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。</span><br>
<span>堆栈数据结构使用两种基本操作：推入（push）和弹出（pop）：</span><br>
<ul>
<span>推入：将数据放入堆栈的顶端（阵列形式或串行形式），堆栈顶端top指标加一。</span><span>弹出：将顶端数据资料输出（回传），堆栈顶端资料减一。</span></ul>
<span>静态  静态变量（Static Variable）在[url=x-dictionary:r:]计算机编程[/url]领域指在[url=x-dictionary:r:]程序[/url]执行前系统就为之静态分配（也即在运行时中不再改变分配情况）存储空间的一类[url=x-dictionary:r:]变量[/url]。与之相对应的是在运行时只暂时存在的[url=x-dictionary:r:]自动变量[/url]（即局部变量）与以[url=x-dictionary:r:]动态分配[/url]方式获取存储空间的一些对象，其中自动变量的存储空间在[url=x-dictionary:r:]调用栈[/url]上分配与释放。</span><br>
<span> ^=========堆 栈 静态===========^</span><br>
<span><br>
</span><br>
<span>3.静态变量</span><br>
<span> 静态变量拥有全局边变量的特征  静态 变量只会执行一次</span><br>
<span>4.设置图片可交互(查)</span><br>
<span>_imgView.userInteractionEnabled = YES;</span><br>
<span>5.  裁剪多余部分,只留下相交部分(实际还存在 只是不显示)</span><br>
<span>  vi.clipsToBounds=YES      vi:父视图 沿着父视图边界剪切子视图超出部分,只留下重叠部分</span><br>
<span>NSLog(@"%@",NSStringFromCGRect(imageView))</span><br>
<span>6.  代理</span><br>
<span> 6.1 代理？？？n.</span><br>
<span> 代理人，代理商。。。</span><br>
<span> 6.2 协议 约定 规则。 协议方法。</span><br>
<span> @protocol 定义协议</span><br>
<span> @protocol</span><br>
<span> …协议方法</span><br>
<span><br>
</span><br>
<span> @end</span><br>
<span> alertView actionSheet默认都有协议方法。当设置delegate，实现了协议方法，并且明确触发事件（比如点击   alertView上的按钮），这样就能够自动是响应协议方法。</span><br>
<span>  6.3 触发事件。只是为了明确何时调用协议方法。</span><br>
<span>设置代理&gt;&gt;&gt;定义协议&gt;&gt;&gt; 触发事件&gt;&gt;&gt;代理实现协议</span><br>
<span></span><br>
<span><br>
</span><br>
<span>1 透明色</span><br>
<span> [UIColor clearcolor]</span><br>
<span><br>
</span><br>
<span>2 delegate和protocol是共存亡的</span><br>
<span> 触发事件做了一件事[delegate protocol]</span><br>
<span>3 (当协议在多个类中使用时可以把协议独立出来)协议可以单独写在一个文件中,使用时倒入协议头文件就行,@class可以避免交叉倒入的错误.</span><br>
<span>4 基础协议  NSObject</span><br>
<span> @protocol ZYCustomAlertDelegate &lt;NSObject&gt; </span><br>
<span> //定义了一个协议 协议名为ZYCustomAlertDelegate 并且实现了基础协议NSObject</span><br>
<span>   入口方法就是协议方法</span><br>
<span>==============================================================</span><br>
<span>1 背景图片</span><br>
<span> <a rel="nofollow" target="_blank" href="mailto:bg@2x.jpg">bg@2x.jpg</a> @2x 适配高清屏（retina）</span><br>
<span> 640 * 960</span><br>
<span> 640 * 1136</span><br>
<span></span><br>
<span></span><br>
<span>bg.jpg  (320 * 480) 不用了。</span><br>
<span><a rel="nofollow" target="_blank" href="mailto:bg@2x.jpg">bg@2x.jpg</a> (640 * 960)</span><br>
<span><a rel="nofollow" target="_blank" href="mailto:bg@568h.jpg">bg@568h.jpg</a> (640 * 1136)</span><br>
<span>2 按钮图片</span><br>
<span>按钮在想以图片显示时，必须考虑按钮的类型。</span><br>
<span>SystemType setBackgroundImage</span><br>
<span></span><br>
<span>Custom   setBackgroundImage</span><br>
<span>      setImage</span><br>
<span>设置背景图片的同时是可以设置标题的。</span><br>
<span>btn setBackgroundImage:[UIImage imageNamed:@"s_0.png"] forState:UIControlStateNormal];</span><br>
<span>3 导航条隐藏</span><br>
<span>    搜索界面导航条不隐藏</span><br>
<span>self.navigationController.navigationBarHidden = NO;</span><br>
<span><br>
</span><br>
<span>4 URL（Uniform Resource Locator） 统一资源定位符 网址</span><br>
<span><br>
</span><br>
<span>5 泛型遍历</span><br>
<span> for (ZYBtn *btn in _itemArray)   </span><br>
<span><br>
</span><br>
<span>6 数组的简便写法</span><br>
<span>  创建数组 (只能创建不可变数组) NSArray* _urlArry = @[@"1",@"2"];</span><br>
<span>  取对象               _urlArry[0];</span><br>
<span>6 颜色宏定义</span><br>
<span>#define RGBA(r,g,b,a) [UIColor colorWithRed:r/255.0 green:g/255.0 blue:b/255.0 alpha:a]</span><br>
<span></span><br>
<span>=====================================================</span><br>
<span>1 . label标题居中</span><br>
<span>_lable.textAlignment = NSTextAlignmentCenter</span><br>
<span>2 按钮选中时</span><br>
<span>[btn setBackgroundImage:[UIImage imageNamed:@"w_xq1.png"] forState:UIControlStateSelected];</span><br>
<span><br>
</span><br>
<span>协议方法前面都有一个当前类的对象是为了,当前类创建多个对象时用于区分;</span><br>
<span><br>
</span><br>
<span>3 #pragma mark -快速定位方法</span><br>
<span><br>
</span><br>
<span>=================================</span><br>
<span>==================</span><br>
<span> 20140806 星期三</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 UIPickerView</span><br>
<span>选择器</span><br>
<span>//  设置picker的数据源和代理，目的是将来为了调用协议方法</span><br>
<span>  picker.dataSource = self;</span><br>
<span>  picker.delegate = self;</span><br>
<span>// 设置显示中间的那两条线（选择指示器）</span><br>
<span>  picker.showsSelectionIndicator = YES;</span><br>
<span>#pragma mark 标记</span><br>
<span><br>
</span><br>
<span>2 协议方法分为两种 必须实现的协议方法 @required</span><br>
<span>          可选择的协议方法       @optional</span><br>
<span>3 // 获取两列中已经选择的行号</span><br>
<span>  _firstRow = [pickerView selectedRowInComponent:0];</span><br>
<span>  _secondRow = [pickerView selectedRowInComponent:1];</span><br>
<span><br>
</span><br>
<span>// 指定显示某列某行</span><br>
<span>  [_picker selectRow:1 inComponent:0 animated:YES];</span><br>
<span>  [_picker selectRow:1 inComponent:1 animated:YES];</span><br>
<span><br>
</span><br>
<span>重新加载（刷新） 所有 的 列</span><br>
<span> reloadAllComponents 会重新的调用pickerView的所有的与pickerView构建和显示相关的协议方法。</span><br>
<span>  [_picker reloadAllComponents];</span><br>
<span></span><br>
<span>指定刷新某列</span><br>
<span>  [_picker reloadComponent:0];</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>4  字典</span><br>
<span>字典分为不可变字典  NSDictionary     和可变字典  NSMutableDictionary</span><br>
<span>1 字典中的键与值是一一对应，一个键只对应一个值，不能存储相同的键。</span><br>
<span>  2 字典是无序的。</span><br>
<span><br>
</span><br>
<span> 4.1 NSDictionary 和 NSMutableDictionary—字典,其条目储存为键-值对;键是唯一的标识符,通 常为字符串,而值则是您要储存的对象。通过指定键,您可以访问该对象。</span><br>
<span><br>
</span><br>
<span>NSDictionary *dic = [[NSDictionary  alloc]initWithObjectsAndKeys:@"laosun",@"L",@"zhiyou",@"Z",@"1",@"num",@"a",@"char",nil];</span><br>
<span><br>
</span><br>
<span>_dic = [[NSDictionary alloc]initWithObjectsAndKeys:@[@"1",@"2",@"3"],@"number",@[@"l",@"a",@"o",@"sun"],@"zhiyou", nil];</span><br>
<span> 4.2 // 获取dic中所有的 值（allObjects）</span><br>
<span> NSArray *values = [_dic allValues];</span><br>
<span> 4.3 // 获取dic中所有的 键</span><br>
<span>  _keysArr = [_dic allKeys];</span><br>
<span> 4.4 通过键值取对象</span><br>
<span>id obj = [dic objectForKey:@"L"];</span><br>
<span><br>
</span><br>
<span>5 UIDatePicker  日期选择器</span><br>
<span> @interface UIDatePicker : UIControl &lt;NSCoding&gt;</span><br>
<span><br>
</span><br>
<span> 5.0</span><br>
<span>  设置模式 默认显示的模式是日期和时间</span><br>
<span>  datePicker.datePickerMode = UIDatePickerModeDateAndTime;</span><br>
<span><br>
</span><br>
<span> 5.1  UIDatePicker *datePicker = (UIDatePicker *)sender;</span><br>
<span></span><br>
<span></span><br>
<span>  NSLog(@"当前的日期和时间为 %@",datePicker.date);</span><br>
<span></span><br>
<span>// 2014-08-06 10:12:23 +0000 格林尼治时间 0 时区 北京的时间 东八区。</span><br>
<span></span><br>
<span>// 日期格式化类</span><br>
<span>NSDateFormatter *formatter = [[NSDateFormatter alloc]init];</span><br>
<span><br>
</span><br>
<span></span><br>
<span>// G  纪元 AD 公元</span><br>
<span>// yyyy 年 2014</span><br>
<span>// MM  月 08</span><br>
<span>// M  月 8</span><br>
<span>// dd  日 06</span><br>
<span>// d  日 6</span><br>
<span>// eeee 星期 Wednesday</span><br>
<span>// eee 星期 Wed</span><br>
<span>// ee  星期 04</span><br>
<span>// e  星期 4</span><br>
<span>// a  上下午 PM</span><br>
<span>// hh  时  05 12小时制</span><br>
<span>// HH  时  17 24小时制</span><br>
<span>// mm/m 分  03/3</span><br>
<span>// ss/s 秒  08/8</span><br>
<span></span><br>
<span></span><br>
<span></span><br>
<span>// 设置日期的格式</span><br>
<span>  [formatter setDateFormat:@"G yyyy年MM月dd日 eeee a HH:mm:ss"];</span><br>
<span></span><br>
<span>// 设置星期，要从星期日开始呀</span><br>
<span>  [formatter setWeekdaySymbols:@[@"星期日",@"星期一",@"星期二",@"星期三",@"星期四",@"星期五",@"星期六"]];</span><br>
<span></span><br>
<span>  [formatter setAMSymbol:@"上午"];</span><br>
<span>  [formatter setPMSymbol:@"下午"];</span><br>
<span></span><br>
<span>// stringFromDate 通过formatter设置的日期格式将datePicker显示的date变成string。</span><br>
<span>  NSString *dateStr = [formatter stringFromDate:datePicker.date];</span><br>
<span></span><br>
<span>  NSLog(@"=====&gt; %@",dateStr);</span><br>
<span></span><br>
<span>  _textField.text = dateStr;</span><br>
<span><br>
</span><br>
<span>6 NSDate</span><br>
<span>NSDate *date = [NSDate date];  返回当前类的对象</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>1 内存管理</span><br>
<span>  分配alloc和释放release</span><br>
<span>  c c++手动管理    特点:执行效率非常高,开发时较为复杂</span><br>
<span>  java 自动内存管理 ,边运行程序边进行垃圾回收,方便了开发者,牺牲了执行效率</span><br>
<span> oc 半自动内存管理,不需要直接释放,只需要告诉系统什么时候释放即可,通过”引用计数”来告诉系统是否要被释放,当引用计数为0时系统就释放该对象,释放后该对象的”引用计数将消失”,即retainCount不存在了.(retainCount是NSObject的属性)</span><br>
<span><br>
</span><br>
<span>// 内存管理（在非ARC下）</span><br>
<span>// 内存的分配和释放。</span><br>
<span>// 创建一个对象就占内存，如果对象不再使用，则释放掉。</span><br>
<span></span><br>
<span> 引用次数不会打印为0,语句会调用该类的dealloc方法,该方法的执行就意味着指针所指的对象已经彻底释放(查)</span><br>
<span><br>
</span><br>
<span> 1.1</span><br>
<span>// 对于一个对象释放彻底释放，需要明确该对象的引用计数是否为0.</span><br>
<span>// 引用计数只能作为内存管理的参考。</span><br>
<span></span><br>
<span>// 1 创建一个对象，则对象的引用计数默认为1</span><br>
<span>// 2 retain方法会使得对象的引用计数+1</span><br>
<span>// 3 release方法......-1</span><br>
<span>// 4 retainCount减到0时会自动调用该对象的类的dealloc方法，而此方法的执行，意味着该对象彻底释放掉。</span><br>
<span>// 5 对象已经释放了，那么以后就不要再使用该对象，以免引起程序的crash</span><br>
<span>// 6 引用计数只能作为内存管理的参考。</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>(Xcode5以上arc Automatic Reference Count 即自动管理引用计数 使用次数 （有多少指针指向）)</span><br>
<span><br>
</span><br>
<span>1.2 *类对象的内存管理</span><br>
<span>   1.2.1凡是通过alloc,new,copy创建的对象引用计数都为1</span><br>
<span>   1.2.2 查看引用次数:NSLog(“%d”,指针.retainCount)</span><br>
<span>   1.2.3[指针 retain]   引用计数加1</span><br>
<span>   1.2.4[指针 release]  引用计数减1</span><br>
<span>   1.2.5 系统即将释放对象时,所有生物全局指针在dealloc方法中进行release</span><br>
<span>   1.2.6局部指针在方法结束之前release</span><br>
<span>   1.2.7内存泄露:一个指针指向一个对象之后,在对另一个对象初始化时,再次使用该指针,前面的一个对象必须先背释放,即改变指向对象时,把之前的对象release.否则前一个对象无法通过指针找到,在程序结束之前将一直存在,即内存泄露.(有内存未被释放),内存泄露过度程序将崩溃.</span><br>
<span> 如果某个指针经常改变指向对象,可以对该指针进行属性描述,打点调用,之后不需要考虑内存问题.</span><br>
<span> 1.2.8 alloc(new,copy)与release,  retain和release必须成对出现.</span><br>
<span>  1.2.9 内存管理原则:谁创建(alloc)谁释放(release),谁使用(retain)谁释放(release)</span><br>
<span>  1.2.10 release过度(过度释放)会使程序崩溃</span><br>
<span><br>
</span><br>
<span>1.3 控件的的类存管理</span><br>
<span>  1.3.1assSubview会使控件的引用次数加1;</span><br>
<span>  1.3.2把对象放入数组,对象的引用次数加1,放进去几次加几次,谁使用谁管理内存,如果把前面的一个数组放进另一个数组,前一个数组里的对象的引用计数不会再增加;</span><br>
<span><br>
</span><br>
<span>1.4 @property的内存管理由系统自动完成</span><br>
<span>1.5加号方法创建的对象会自动释放autorelease</span><br>
<span><br>
</span><br>
<span> 1.5.1 autorelease 自动释放，不是立马释放，会把lab对象添加到NSAutoReleasePool中 将来 会完成释放。</span><br>
<span>对一个对象释放十分确定，则直接使用release方法，如果对对象不是立马释放，则使用autorelease。</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>1.6 基本类型(变量)不需要内存管理,(变量和指针的存放位置不同)</span><br>
<span><br>
</span><br>
<span>1.7 NSTimer如果未被释放则不会执行dealloc方法,所以页面结束之前一定要摧毁NSTimer,指针设为空</span><br>
<span>1.8  UIImage用imageName创建的图片,系统自动释放 autorelease ,除非程序结束否则图片基本不会被释放,如果图片过多,内存占用过多时还是alloc为妙</span><br>
<span><br>
</span><br>
<span>1.9导航器的内存管理</span><br>
<span>  push会增加引用计数,pop会释放,和压栈出栈有关</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>2 属性描述类型</span><br>
<span> 基本类型用(nonatomic,assign)</span><br>
<span> 对象指针用(nonatomic,retain)</span><br>
<span> 字符串类型(nonatomic,copy)l</span><br>
<span> delegate描述用(nonatomic,assign)delegate:防止相互retain更改get方法名时(nonatomic,getter = is…..);</span><br>
<span><br>
</span><br>
<span>3 内存管理原则</span><br>
<span> 3.1 谁创建谁释放,谁使用谁释放</span><br>
<span> 3.2创建者或者使用者不在使用对象就可以释放他,但是不要释放他人的引用</span><br>
<span> 3.3如果要使用一个对象,则一定要保证该对象的创建时,要对该对象retain</span><br>
<span><br>
</span><br>
<span>4 苹果官方  基础内存管理规则</span><br>
<span>  4.1 你拥有你创建的任何对象</span><br>
<span>  4.2 你可以使用retain获取一个对象的拥有权</span><br>
<span>  4.3 当你不再需要它,你必须放弃你拥有的对象的拥有权</span><br>
<span>  4.4 你一定不能释放不是你拥有的对象的拥有权</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>类都用dealloc释放</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>1 表视图 UITableView </span><br>
<span>UITableView 继承与UIScrollView   UITableView : UIScrollView</span><br>
<span>  因为其继承与UIScrollView所以 </span><br>
<span>tableView.dataSource = self;</span><br>
<span>  tableView.delegate = self;</span><br>
<span></span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>contentView</span><br>
<span>如果放在self.view上,不容易找到  bounces 回弹 </span><br>
<span><br>
</span><br>
<span>1 自定义cell  3种方式</span><br>
<span> 1.1在if里面创建 添加(contentView),  在if语句外完成配置.(return的cell要么是新建的,要么是重用的)</span><br>
<span>每个cell在tableView中的indexPath时唯一的.重用的的时cell的对象,但是indexPath不会改变</span><br>
<span>    //indexPathForCell 在表中 cell对应的索引路径</span><br>
<span>NSIndexPath *indexPath = [_tableView indexPathForCell:cell];</span><br>
<span>NSLog(@"当前按钮所在的cell，在表中的位置为第%d区，第%d行",indexPath.section,indexPath.row);</span><br>
<span><br>
</span><br>
<span> 1.2 自定义类继承自UITableViewCell  ZYTableViewCell : UITableViewCell</span><br>
<span>   在自定义方法中完成创建相应控件,在 - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath 方法中直接打点调用</span><br>
<span><br>
</span><br>
<span> 1.3 加载XIB</span><br>
<span></span><br>
<span>//加载xib  Bundle 捆</span><br>
<span>NSArray*xib = [[NSBundle mainBundle]loadNibNamed:@"ZYTableViewCell" owner:nil options:nil];</span><br>
<span>//遍历数组找到cell</span><br>
<span>    for (id obj in xib)</span><br>
<span>    {</span><br>
<span>      if ([obj isKindOfClass:[ZYTableViewCell class]])</span><br>
<span>      {</span><br>
<span>//如果对象时ZYTableViewCell,那么就直接把对象强制类型转换成cell</span><br>
<span>        cell = (ZYTableViewCell*)obj;</span><br>
<span>        break;</span><br>
<span>      }</span><br>
<span>    }</span><br>
<span><br>
</span><br>
<span>2 通过btn找cell </span><br>
<span>ZYTableViewCell*cell = (ZYTableViewCell*)btn.superview.superview.superview;</span><br>
<span>  NSString*str = [NSString stringWithFormat:@"%@"@"--"@"%@",cell.label1.text,cell.label2.text];</span><br>
<span><br>
</span><br>
<span>3. CGAffineTransform 仿射变换</span><br>
<span> 3.1 移动</span><br>
<span>_imageView.transform = CGAffineTransformMakeTranslation(100, 100);</span><br>
<span>3.2 缩放</span><br>
<span>_imageView.transform = CGAffineTransformMakeScale(2, 2);</span><br>
<span>3.3 累计方法缩小 n倍</span><br>
<span>_imageView.transform = CGAffineTransformScale(_imageView.transform, 0.5, 0.5);</span><br>
<span>3.4 旋转</span><br>
<span>_imageView.transform = CGAffineTransformMakeRotation(_angle);_angle是弧度值</span><br>
<span></span><br>
<span>1 tableView的类型</span><br>
<span> 1.1 UITableViewStylePlain 没有区头 不显区头   向上滑动区头不会移动到屏幕外面</span><br>
<span>’ 1.2 UITableViewStyleGrouped 有区头     表滑动,区头会移动</span><br>
<span>2 cell accessory  cell的配件</span><br>
<span>//cell配件(accessory)</span><br>
<span>// 0 none 什么也没有</span><br>
<span>// 1 DisclosureIndicator 多了一个指向右侧的按钮</span><br>
<span>// 2 DetailButton 详细信息按钮</span><br>
<span>  // 3 Checkmark 对勾</span><br>
<span>// 4 DetailDisclosureButton 详细信息按钮 + 指向右侧的箭头</span><br>
<span>  cell.accessoryType = UITableViewCellAccessoryDetailDisclosureButton;</span><br>
<span><br>
</span><br>
<span>  还可以在设置huadong</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>3 设置cell 选中状态</span><br>
<span>//设置选择类型 默认为灰底</span><br>
<span>  cell.selectionStyle = UITableViewCellSelectionStyleDefault;</span><br>
<span></span><br>
<span>4 NSCopying 协议 作用是只有实现此方法的类就可以调用copy方法</span><br>
<span>系统的某些类是默认实现NSCopying协议,诸如NSSting,NSArray,NSDictionary等;</span><br>
<span>   所以 之前的People的类的对象默认是不能调用copy方法,因为People没有实现NSCopying协议中的copyWithZone方法.</span><br>
<span>  临时字符串的引用计数是 -1 NSString *str = @"laosun";</span><br>
<span>通过创建字符串的对象的方式 引用计数为1 可以进行拷贝 引用计数加 1 效果等同于retain </span><br>
<span> NSString *str1 = [NSString stringWithFormat:@"laosun"];</span><br>
<span><br>
</span><br>
<span> 4.1 浅拷贝 copy</span><br>
<span>      retain拷贝的时指针,对象只有一个,结果使得对象的引用计数 + 1</span><br>
<span> 4.2 深拷贝 真正意义上的拷贝,只是要产生两个对象,而且每个对象的引用计数是1</span><br>
<span><br>
</span><br>
<span>5 // 此属性就可以代替 设置区头高度的 协议方法</span><br>
<span>_tableView.sectionHeaderHeight = 50;</span><br>
<span><br>
</span><br>
<span>6 创建tableView所必须的三个方法</span><br>
<span>  6.1 //在tableView上有几个区域</span><br>
<span>- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView</span><br>
<span>6.2 //每个区域有多上行</span><br>
<span> - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section</span><br>
<span>6.3 每一行的cell</span><br>
<span>  - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>7 相关协议</span><br>
<span>7.1区头需要多个控件 则可以先创建一个View,然后再view上添加控件,view和相关控件在如下的方法中创建</span><br>
<span>-(UIView*)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section;</span><br>
<span><br>
</span><br>
<span> 7.2 设置cell的编辑风格</span><br>
<span>  - (UITableViewCellEditingStyle)tableView:(UITableView *)tableView editingStyleForRowAtIndexPath:(NSIndexPath *)indexPath;</span><br>
<span><br>
</span><br>
<span>  风格类型</span><br>
<span>  7.2.1 UITableViewCellEditingStyleDelete   删除</span><br>
<span>7.2.2   UITableViewCellEditingStyleInsert 插入</span><br>
<span>  7.2.3 UITableViewCellEditingStyleNone    默认</span><br>
<span><br>
</span><br>
<span> 7.3 cell是否可以移动 返回的时一个BOOL值</span><br>
<span>- (BOOL)tableView:(UITableView *)tableView canMoveRowAtIndexPath:(NSIndexPath *)indexPath</span><br>
<span><br>
</span><br>
<span>  7.3.1 用来移动的三杠</span><br>
<span>  - (void)tableView:(UITableView *)tableView moveRowAtIndexPath:(NSIndexPath *)sourceIndexPath toIndexPath:(NSIndexPath *)destinationIndexPath</span><br>
<span><br>
</span><br>
<span>移动逻辑: 取&gt;删&gt;添加</span><br>
<span><br>
</span><br>
<span> 7.4 完成编辑</span><br>
<span><br>
</span><br>
<span>    -(void)tableView:(UITableView *)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br>
<span><br>
</span><br>
<span>删除和插入所做的操作写在这里 删除逻辑:删除对象 &gt; 删除行 </span><br>
<span><br>
</span><br>
<span>8 展开闭合逻辑:</span><br>
<span>通过一个bool值判断(_falg[3]),如果是yes则返回相应数组的count,否则返回0 (在和行相关的方法中),刷新相应的行的数据</span><br>
<span><br>
</span><br>
<span>9  表的编辑 增 ,删 ,移</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>www.tinyletter.com <a rel="nofollow" target="_blank" href="http://www.stackoverflow.com/" id="url_1">
www.stackoverflow.com</a></span><br>
<br>
<br>
<span>1  工具栏  UIToolbar</span><br>
<span>2  textField 协议方法</span><br>
<span>一旦TextField成为第一响应,此方法就会调用</span><br>
<span>- (void)textFieldDidBeginEditing:(UITextField *)textField</span><br>
<span>3  当点击textFiled时键盘弹上去 同时消息内容向上滑动,表紧挨着键盘显示最后一行数据</span><br>
<span>- (void)scrollToRowAtIndexPath:(NSIndexPath *)indexPath atScrollPosition:(UITableViewScrollPosition)scrollPosition animated:(BOOL)animated;</span><br>
<span>4  图片拉伸  stretch 拉伸  以左边的宽和上边的高度 沿边界  顶盖的覆盖区域不进行缩放和调整大小</span><br>
<span>UIImage *handsomeImage = [uglyImage stretchableImageWithLeftCapWidth:25 topCapHeight:15];</span><br>
<span>5</span><br>
<span>// 注册一个类（cell class） IOS6</span><br>
<span> // 创建的cell 默认类型是Default，如果想要改变cell的类型，必须自定义一个UITableViewCell的子类。</span><br>
<span> // [tableView registerClass:[TableViewCell class] forCellReuseIdentifier:cellIdentifier];</span><br>
<span>6 ZYTableViewController </span><br>
<span> 6.1 需要创建导航器</span><br>
<span> 6.2 viewDidLoad</span><br>
<span> 6.2.1</span><br>
<span>// 当当前的view将要显示时，是否清空cell的选中状态。 如果为NO，则pop回来之后，仍然记录之前cell的选中状态。</span><br>
<span>self.clearsSelectionOnViewWillAppear = NO;</span><br>
<span> 6.2.2</span><br>
<span>  // 在导航条上右边会出现一个'Edit'按钮，默认实现表的编辑状态的改变。</span><br>
<span>self.navigationItem.rightBarButtonItem = self.editButtonItem;</span><br>
<span><br>
</span><br>
<span>[[NSBundle mainBundle] pathForResource:&lt;#(NSString *)#&gt; ofType:&lt;#(NSString *)#&gt;]找到某一个资源</span><br>
<span><br>
</span><br>
<span><br>
</span><br>
<span>==================</span><br>
<span> 20140814 星期四</span><br>
<span>==================</span><br>
<span><br>
</span><br>
<span>1 沙盒</span><br>
<span> 1.1 IOS中每一个应用程序都有一个单独封闭的文件夹,这个文件夹称为沙盒</span><br>
<span> 1.2 沙盒目录用来存放APP的本地文件,例如:音频,视频,图片文件.....</span><br>
<span> 1.3 当前APP应用程序没有权限访问其他APP的沙盒(更安全).</span><br>
<span> 1.4 模拟器上的沙盒路径</span><br>
<span>/Users/zhiyou3g/Library/Application Support/iPhone Simulator/7.1/Applications</span><br>
<span> 1.5 沙盒中有如下子目录</span><br>
<span>     Documents  存放长期使用文件</span><br>
<span>     Library       系统存放文件</span><br>
<span>     tmp         临时文件,APP重启,该目录下的文件会清空</span><br>
<span>2  路径用NSString来描述</span><br>
<span>  2.1 获取沙盒主目录路径</span><br>
<span>//沙盒主目录</span><br>
<span>  NSString*homePath = NSHomeDirectory();</span><br>
<span>  NSLog(@"homePath==%@",homePath);</span><br>
<span> 2.2 在主目录下搜索其他目录</span><br>
<span>//从主目录下搜索</span><br>
<span></span><br>
<span>//Documents目录</span><br>
<span>  NSString*documentsPath = [homePath stringByAppendingPathComponent:@"Documents"];</span><br>
<span>  NSLog(@"documentsPath==%@",documentsPath);</span><br>
<span></span><br>
<span>//library目录</span><br>
<span>  NSString*libraryPath = [homePath stringByAppendingPathComponent:@"Library"];</span><br>
<span>NSLog(@"libraryPath==%@",libraryPath);</span><br>
<span></span><br>
<span>//tmp目录</span><br>
<span>NSString*tmpPath = [homePath stringByAppendingPathComponent:@"tmp"];</span><br>
<span>  NSLog(@"tmpPath==%@",tmpPath);</span><br>
<span>====================================</span><br>
<span>====================================</span><br>
<span>//1  获取路径</span><br>
<span></span><br>
<span>//沙盒主目录</span><br>
<span>  NSString*homePath = NSHomeDirectory();</span><br>
<span>  NSLog(@"homePath==%@",homePath);</span><br>
<span></span><br>
<span>//从主目录下搜索</span><br>
<span></span><br>
<span>//Documents目录</span><br>
<span>  NSString*documentsPath = [homePath stringByAppendingPathComponent:@"Documents"];</span><br>
<span>  NSLog(@"documentsPath==%@",documentsPath);</span><br>
<span></span><br>
<span>//library目录</span><br>
<span>  NSString*libraryPath = [homePath stringByAppendingPathComponent:@"Library"];</span><br>
<span> NSLog(@"libraryPath==%@",libraryPath);</span><br>
<span></span><br>
<span>//tmp目录</span><br>
<span>NSString*tmpPath = [homePath stringByAppendingPathComponent:@"tmp"];</span><br>
<span>  NSLog(@"tmpPath==%@",tmpPath);</span><br>
<span>//============================================</span><br>
<span>//  1 2 两部分都用 stringByAppendingPathComponent 但是一般把第一部分称为搜索,第二部分称为追加,其实二者功能是一样的都是把路径保存到字符串中,说追加更合理,否则容易造成误解</span><br>
<span>//   路径其实就是一串字符串</span><br>
<span>//============================================</span><br>
<span></span><br>
<span>//2 NSString处理路经</span><br>
<span>//演示路径  /Users/apple/file.text</span><br>
<span>NSString*demoPath = @"/Users/apple/file.text";</span><br>
<span></span><br>
<span>// 2.1 获取路径的组成部分 "/" "Users"  "apple"  "File.text"</span><br>
<span>  NSArray *components = [demoPath pathComponents];</span><br>
<span>NSLog(@"demoPathComponents===%@",components);</span><br>
<span>// 2.2 获取路径的最后一个组成部分</span><br>
<span>  NSString*lastName = [demoPath lastPathComponent];</span><br>
<span>  NSLog(@"lastName===%@",lastName);</span><br>
<span>// 2.3 追加文件或目录  /Users/apple/file.text/app.text</span><br>
<span>  NSString*addFilePath = [demoPath stringByAppendingPathComponent:@"app.text"];</span><br>
<span>  NSLog(@"追加%@",addFilePath);</span><br>
<span></span><br>
<span>//2.4删除最后的部分</span><br>
<span>  NSString*afterDeletePath = [addFilePath stringByDeletingLastPathComponent];</span><br>
<span>  NSLog(@"deleteAfterPath===%@",afterDeletePath);</span><br>
<span>// 2.5 取得最后部分扩展名</span><br>
<span>  NSString*extName = [afterDeletePath pathExtension];</span><br>
<span>  NSLog(@"extName===%@",extName);</span><br>
<span></span><br>
<span>// 2.6 追加扩展名</span><br>
<span>  NSString*addExtNamePath = [afterDeletePath stringByAppendingPathExtension:@"jpg" ];</span><br>
<span>  NSLog(@"addExtNamePath===%@",addExtNamePath);</span><br>
<span></span><br>
<span></span><br>
<span></span><br>
<span>// 3  NSData</span><br>
<span>//NSData是对数据的一种抽象.任何数据都可以通过NSData来存储,NSMutableData是可变的,继承NSData</span><br>
<span>// 4 NSFileManager   创建 复制 删除 剪切</span><br>
<span></span><br>
<span>// 4.1 NSFileManager管理文件常用办法</span><br>
<span></span><br>
<span>// 4.2创建文件</span><br>
<span>//创建NSFileManager对象</span><br>
<span>NSFileManager*fileManager = [NSFileManager defaultManager];</span><br>
<span>  NSString*homePath1 = NSHomeDirectory();</span><br>
<span>NSLog(@"homePath1====%@",homePath1);</span><br>
<span>NSString*pathMg = [homePath1 stringByAppendingPathComponent:@"liRuYi2.text"];</span><br>
<span>//创建内容</span><br>
<span>NSString*text = @"媒介生而平等，但有的媒介比其它媒介更加平等,不是人们不读书了，而是文字阅读已经不再是唯一有价值、有营养的阅读形态了。";</span><br>
<span>//将字符串转换成NSData类型</span><br>
<span>NSData*date = [text dataUsingEncoding:NSUTF8StringEncoding];</span><br>
<span>//写入文件</span><br>
<span>  BOOL success = [fileManager createFileAtPath:pathMg contents:date attributes:nil];</span><br>
<span>  NSLog(@"%d",success);</span><br>
<span><br>
</span><br>
<span></span><br>
<span>//  4.3读取文件</span><br>
<span>//  4.3.1 创建NSFileManager对象</span><br>
<span>NSFileManager*fileManager2 = [NSFileManager defaultManager];</span><br>
<span>//4.3.2  根据路径读取文件</span><br>
<span>  NSData*fileDate = [fileManager2 contentsAtPath:pathMg];</span><br>
<span>//4.3.3  将NSDate转换成NSString</span><br>
<span>NSString*content = [[NSString alloc] initWithData:fileDate encoding:NSUTF8StringEncoding];</span><br>
<span>NSLog(@"content=====%@",content);</span><br>
<span></span><br>
<span>//  4.4 剪切复制</span><br>
<span>  NSString*homePath3 = NSHomeDirectory();</span><br>
<span>//源文件路径</span><br>
<span>NSString*srcPath = [homePath3 stringByAppendingPathComponent:@"liRuYi2.text"];</span><br>
<span>//目标路径</span><br>
<span>NSString*toPath = [homePath3 stringByAppendingPathComponent:@"Documents/file.text"];</span><br>
<span>//4.4.1剪切(移动)文件</span><br>
<span>//将src路径的文件剪切到toPath路径</span><br>
<span>  BOOL isSuccess = [fileManager2 moveItemAtPath:srcPath toPath:toPath error:nil];</span><br>
<span>  NSLog(@"%d",isSuccess);</span><br>
<span></span><br>
<span>//4.4.2 复制文件</span><br>
<span>//源文件路径</span><br>
<span>  NSString*srcPath2 = [homePath3 stringByAppendingPathComponent:@"file.text"];</span><br>
<span>//目标路径</span><br>
<span>NSString*toPath2 = [homePath3 stringByAppendingPathComponent:@"Library/good.text"];</span><br>
<span></span><br>
<span>  BOOL success2 = [fileManager2 copyItemAtPath:srcPath2 toPath:toPath2 error:nil];</span><br>
<span>  NSLog(@"%d",success2);</span><br>
<span></span><br>
<span></span><br>
<span>//  4.5 删除文件</span><br>
<span>//判断文件是否存在</span><br>
<span></span><br>
<span>  NSString*deletePath = [homePath3 stringByAppendingPathComponent:@"liRuYi2.text"];</span><br>
<span></span><br>
<span>  BOOL isExist = [fileManager2 fileExistsAtPath:deletePath];</span><br>
<span>  if (isExist) {</span><br>
<span>    //删除文件</span><br>
<span>    BOOL seccessDelete = [fileManager2 removeItemAtPath:deletePath error:nil];</span><br>
<span>    if (seccessDelete) {</span><br>
<span>NSLog(@"remove success");</span><br>
<span></span><br>
<span>UIAlertView*alertView = [[UIAlertView alloc] initWithTitle:nil message:@"remove success" delegate:self cancelButtonTitle:nil otherButtonTitles:@"确定", nil];</span><br>
<span>      [alertView show];</span><br>
<span></span><br>
<span></span><br>
<span></span><br>
<span>    }</span><br>
<span>  }</span><br>
<span></span><br>
<span>//  4.6获取文件大小</span><br>
<span>//获取文件的属性字典</span><br>
<span>  NSDictionary*fileDic = [fileManager2 attributesOfItemAtPath:toPath2 error:nil];</span><br>
<span>//获取文件大小</span><br>
<span>  NSNumber*fileSize = [fileDic objectForKey:NSFileSize];</span><br>
<span>NSLog(@"fileSize=======%@",fileSize);</span><br>
<span></span><br>
<span>//  5 写文件</span><br>
<span>//  数组 字典 字符串 NSData都是容纳数据的,他们都有一个writeToFile的方法</span><br>
<span></span><br>
<span>//5.1数组写入文件</span><br>
<span>  NSString *str1 = @"明月几时有";</span><br>
<span>  NSString *str2 = @"把酒问青天";</span><br>
<span>  NSArray *array = [NSArray arrayWithObjects:str1,str2, nil];</span><br>
<span>NSString*path10 = [homePath stringByAppendingPathComponent:@"hehe.text"];</span><br>
<span>//将数组中的数据写入文件</span><br>
<span>  [array writeToFile:path10 atomically:YES];</span><br>
<span></span><br>
<span>NSString*path11 = [homePath stringByAppendingPathComponent:@"hehe.plist"];</span><br>
<span>  [array writeToFile:path11 atomically:YES];</span><br>
<span></span><br>
<span></span><br>
<span>//  5.2 属性列表文件</span><br>
<span>//  数组只能写入NSNumber NSString NSDate NSData NSArray NSDictionary</span><br>
<span>//  数组,字典写入的文件叫属性列表(plist),可以用xcode打开编辑</span><br>
<span></span><br>
<span></span><br>
<span>//  6 读文件</span><br>
<span>//  数组 字典 字符串 NSData 同样的可以将文件数据读入程序</span><br>
<span>//  6.1数组读文件</span><br>
<span>//通过alloc创建,并读入文件数据</span><br>
<span>  NSArray*array1 = [[NSArray alloc] initWithContentsOfFile:path10];</span><br>
<span>NSLog(@"array1===========%@",array1);</span><br>
<span>//通过类方法创建,并读入文件数据</span><br>
<span>  NSArray*arry2 = [NSArray arrayWithContentsOfFile:path11];</span><br>
<span>NSLog(@"arry2 ===== %@",arry2);</span><br>
<span></span><br>
<span>//  补充 创建文件夹</span><br>
<span>//[[NSSearchPathForDirectoriesInDomains(NSDemoApplicationDirectory, NSUserDomainMask, YES)是一个数组,作用是获取路径</span><br>
<span>NSString*createDir = [[NSSearchPathForDirectoriesInDomains(NSDemoApplicationDirectory, NSUserDomainMask, YES) objectAtIndex:0] stringByAppendingPathComponent:@"test/test/test"];</span><br>
<span>//创建文件夹 createIntermediates该参数bool类型 是否创建文件夹路径中没有的文件夹目录</span><br>
<span>  [fileManager createDirectoryAtPath:createDir withIntermediateDirectories:YES attributes:nil error:nil];</span><br>
<span><br>
</span><br>
<span>return YES;</span><br>
<span></span><br>
<span>========================================</span><br>
<span><br>
</span><br>
<span>========================================</span><br>
<span>bundle是一个目录,其中包含了程序会使用到的资源.这些资源包含了入图像,生音,编译好的代码,nib文件.对bundle,cococa提供了类NSBundle.我们的程序是一个bundle.在Finder中,一个应用程序看上去和其他文件没有区别.但是实际上他是一个包含了nib文件,编译代码,以及其资源的目录,我们            </span></div>
           <div class="ad-under"><script type="text/javascript">ad.bdDesc_336280();</script></div>
        </div>
        <div class="connect">
            <i class="connect-left"></i>
            <i class="connect-right"></i>
        </div>
        <div class="p-extra">
            <h3>猜你在找</h3>
            <ul>
	<li><a href="http://www.aichengxu.com/view/58347" title="【Ios开发】监听通讯录发生变化">【Ios开发】监听通讯录发生变化</a></li><li><a href="http://www.aichengxu.com/view/58369" title="VNC远程登陆ubuntu12.04不能显示桌面, 而只有一个Terminal窗口">VNC远程登陆ubuntu12.04不能显示桌面, 而只有一个Terminal窗口</a></li><li><a href="http://www.aichengxu.com/view/58383" title="ORA-16032: parameter LOG_ARCHIVE_DEST_3 destination string cannot be translated">ORA-16032: parameter LOG_ARCHIVE_DEST_3 destination string cannot be translated</a></li><li><a href="http://www.aichengxu.com/view/58378" title="IOS编程第四版第二章---Managing Memory with ARC">IOS编程第四版第二章---Managing Memory with ARC</a></li><li><a href="http://www.aichengxu.com/view/58377" title="objective-c中的category">objective-c中的category</a></li><li><a href="http://www.aichengxu.com/view/58376" title="iOS设备尺寸、像素对照表">iOS设备尺寸、像素对照表</a></li><li><a href="http://www.aichengxu.com/view/58375" title="iOS根据字符串计算UITextView高度">iOS根据字符串计算UITextView高度</a></li><li><a href="http://www.aichengxu.com/view/58374" title="ViewController生命周期">ViewController生命周期</a></li><li><a href="http://www.aichengxu.com/view/58368" title="[SQL SERVER] 如何linked server連接Oracle (Oracle Provider for OLE DB)">[SQL SERVER] 如何linked server連接Oracle (Oracle Provider for OLE DB)</a></li><li><a href="http://www.aichengxu.com/view/58384" title="开始玩hadoop3--准备装hadoop（ubuntu）">开始玩hadoop3--准备装hadoop（ubuntu）</a></li></ul>
</div>
    </div>
    <div class="post-right">     
        <div id="side-box">
            <h3>阅读榜</h3>
            <ul> <li><span class="list-num hot-num hot-1">1</span><a href="http://www.aichengxu.com/view/738">win7无法添加打印机的原因和解决办法</a></li><li><span class="list-num hot-num hot-2">2</span><a href="http://www.aichengxu.com/view/628">怎么样看以及如何知道对方qq隐身</a></li><li><span class="list-num hot-num hot-3">3</span><a href="http://www.aichengxu.com/view/786">小米上不了网-小米上网设置方法</a></li><li><span class="list-num hot-num ">4</span><a href="http://www.aichengxu.com/view/483">迅雷下载进度99.9%不动解决方法</a></li><li><span class="list-num hot-num ">5</span><a href="http://www.aichengxu.com/view/932">cpu主频是什么意思？越高越好吗？</a></li><li><span class="list-num hot-num ">6</span><a href="http://www.aichengxu.com/view/641">迅雷下载有种子资源却没有速度</a></li><li><span class="list-num hot-num ">7</span><a href="http://www.aichengxu.com/view/515">电脑开机电源指示灯不亮原因分析</a></li><li><span class="list-num hot-num ">8</span><a href="http://www.aichengxu.com/view/723">迅雷离线下载怎么取回本地</a></li><li><span class="list-num hot-num ">9</span><a href="http://www.aichengxu.com/view/625">鼠标点击反应速度太快 变慢方法</a></li><li><span class="list-num hot-num ">10</span><a href="http://www.aichengxu.com/view/569">打开网页速度慢,打开网页慢怎么办,电脑打开网页很慢</a></li></ul>            
        </div>
    </div>
</div>
<script type="text/javascript">
    //右侧浮动
    var oDiv = document.getElementById("side-box");
    var H = 0, iE6;
    var Y = oDiv;
    while (Y) {
        H += Y.offsetTop;
        Y = Y.offsetParent;
    }
    iE6 = window.ActiveXObject && !window.XMLHttpRequest;
    if (!iE6) {
        window.onscroll = function() {
            var s = document.body.scrollTop || document.documentElement.scrollTop;
            if (s > H) {
                oDiv.className = "box-fixed";
                if (iE6) {
                    oDiv.style.top = (s - H) + "px";
                }
            }
            else {
                oDiv.removeAttribute("class");
            }
        };
    }
</script>

		<div id="footer">
                <p>Copyright&nbsp;©&nbsp;2011-2015&nbsp;&nbsp;爱程序网&nbsp;&nbsp;沪ICP备14001972号-1&nbsp;&nbsp;业务咨询：<a target="_blank" href="http://wpa.qq.com/msgrd?v=3&uin=1218824751&site=qq&menu=yes"><img border="0" src="./iOS 知识点总结 笔记总结 - 爱程序网_files/pa" alt="业务咨询" title="业务咨询"></a> &nbsp;&nbsp;技术支持：superyaying(at)qq.com</p>
            </div>
            <script type="text/javascript" src="./iOS 知识点总结 笔记总结 - 爱程序网_files/common.js"></script>
		<!--Baidu Search-->
		<script type="text/javascript">
			/*内文搜索*/
			var cpro_id = "u2051930";
		</script>
		<script src="http://cpro.baidustatic.com/cpro/ui/cnw.js" type="text/javascript"></script>
		<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?5d8a73b687ddb89431a8684d2f1c4afa";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!--站内搜索-->
<script type="text/javascript">(function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=13701196898887196136' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();</script><div id="bdcs"><div class="bdcs-container"><meta http-equiv="x-ua-compatible" content="IE=9">                          </div></div>

<div style="display:none;">
<script src="./iOS 知识点总结 笔记总结 - 爱程序网_files/stat.php" language="JavaScript"></script><script src="./iOS 知识点总结 笔记总结 - 爱程序网_files/core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=4489656" target="_blank" title="站长统计">站长统计</a>
</div>

            
        </div>
    
</body></html>